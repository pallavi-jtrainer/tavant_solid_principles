Day 1:
---------
SOLID priciples:
5 guidelines to create clean, maintainable and flexible code
1. Single Responsibility Principle (S)
2. Open-closed Priciple
3. Liskov Substitution Principle
4. Interface Segregation Principle
5. Dependency inversion Principle


Code Smells

Technical Debt:
1. Intentional
2. Unintentional
3. Bit Rot

To reduce TD:
1. SOLID Priciples
2. Refactoring
3. Adequate testing
4. Track TD
5. Perform Code Reviews
6. Allocate time for refactoring
---------------------------------------------------------------------

Single Responsibility Principle
 -> each class, method or module should do one thing perfectly

Responsibilities:
1. Validation -> OrderValidationService
2. Persistence -> OrderRepository
3. Notification -> OrderNotificationService
4. Business Logic -> OrderService
5. API Endpoint exposure -> OrderController
____________________________________________________________________________________________

Day 2:
OCP
-> Open Closed Principle



Exercise:
Add classes for all different processors + a new class to handle CrptoCurrency
Add test cases for checkout service
Integrate this into the OrderController

2.
Add a OrderDto and Mapper
Add a FestivalDiscount Service
Add a OrderValidatorService

3. Add an InvoiceService that generate Pdf invoice
   Add a NotificationService with a notification sender for email, sms, push and WhatsApp



--------------------------------
Case study hands on
1. Create a new class SlackNotificationService
2. Register with Factory
3. update LoanService
4. Implement an Overdue reminder + overdue amount calculation

_________________________________________________________________________
Day 3:
LSP -> Liskov Substitution Principle
-> By Barbara Liskov in late 1980s
-> ensures proper usage of polymorphism
-> subclasses behave consistently with their superclasses
-> code stays stable and reliable when new implementations are introduced


Ex violating LSP
public class Bird {
	public void fly() { //some behaviour }
}

public class Sparrow extends Bird {
	@Override
	public void fly() { // new behaviour }
}

public class Penguin extends Bird {
	
}
-----------------------------------
Refactoring for LSP compliant code
public interface Bird {
	void eat();
}


public interface FlyingBird extends Bird {
	void fly();
}

public class Sparrow implements FlyingBird {}

public class Penguin implements Bird {}
-------------------------------------------------

Hands On:
1. update the order controller
2. add a shipping controller
3. Add a class LimitedShippingService based on weight calculation
4. Add a new shipping service called SpeedShippingService -> cost per kg is 25, if weight >5kg, should switch to StandardShipping
5. Add a ShippingFactory class
6. Add a Discount Factory

Case Study hands on
1. create a Reservation entity
2. Refactor LoanController to handle the reservation logic
3. Update the mapper to handle this new logic
4. Write test cases
5. Add a Category entity
6. Add member subscription levels

__________________________________________________________________________________________________________________________
Day 4: 
ISP -> Interface Segregation Principle
-> Classes should not be forced to implement what they don't need

Ex:
public interface RestaurantService {   <- Fat Interface
	void takingFoodOrder();
	void serveDrinks();
	void deliverOnline();
	void driveThruService();
}

hands on
1. Create an InvoiceService which depends on the Email Notification service only. 
2. Create a ReportGenerator to generate reports in 3 formats - Pdf, Html, Excel
3. Connect the generator to the EmailNotificationService



