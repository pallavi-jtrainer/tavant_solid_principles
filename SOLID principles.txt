Day 1:
---------
SOLID priciples:
5 guidelines to create clean, maintainable and flexible code
1. Single Responsibility Principle (S)
2. Open-closed Priciple
3. Liskov Substitution Principle
4. Interface Segregation Principle
5. Dependency inversion Principle


Code Smells

Technical Debt:
1. Intentional
2. Unintentional
3. Bit Rot

To reduce TD:
1. SOLID Priciples
2. Refactoring
3. Adequate testing
4. Track TD
5. Perform Code Reviews
6. Allocate time for refactoring
---------------------------------------------------------------------

Single Responsibility Principle
 -> each class, method or module should do one thing perfectly

Responsibilities:
1. Validation -> OrderValidationService
2. Persistence -> OrderRepository
3. Notification -> OrderNotificationService
4. Business Logic -> OrderService
5. API Endpoint exposure -> OrderController
____________________________________________________________________________________________

Day 2:
OCP
-> Open Closed Principle



Exercise:
Add classes for all different processors + a new class to handle CrptoCurrency
Add test cases for checkout service
Integrate this into the OrderController

2.
Add a OrderDto and Mapper
Add a FestivalDiscount Service
Add a OrderValidatorService

3. Add an InvoiceService that generate Pdf invoice
   Add a NotificationService with a notification sender for email, sms, push and WhatsApp



--------------------------------
Case study hands on
1. Create a new class SlackNotificationService
2. Register with Factory
3. update LoanService
4. Implement an Overdue reminder + overdue amount calculation

_________________________________________________________________________
Day 3:
LSP -> Liskov Substitution Principle
-> By Barbara Liskov in late 1980s
-> ensures proper usage of polymorphism
-> subclasses behave consistently with their superclasses
-> code stays stable and reliable when new implementations are introduced


Ex violating LSP
public class Bird {
	public void fly() { //some behaviour }
}

public class Sparrow extends Bird {
	@Override
	public void fly() { // new behaviour }
}

public class Penguin extends Bird {
	
}
-----------------------------------
Refactoring for LSP compliant code
public interface Bird {
	void eat();
}


public interface FlyingBird extends Bird {
	void fly();
}

public class Sparrow implements FlyingBird {}

public class Penguin implements Bird {}
-------------------------------------------------

Hands On:
1. update the order controller
2. add a shipping controller
3. Add a class LimitedShippingService based on weight calculation
4. Add a new shipping service called SpeedShippingService -> cost per kg is 25, if weight >5kg, should switch to StandardShipping
5. Add a ShippingFactory class
6. Add a Discount Factory

Case Study hands on
1. create a Reservation entity
2. Refactor LoanController to handle the reservation logic
3. Update the mapper to handle this new logic
4. Write test cases
5. Add a Category entity
6. Add member subscription levels

__________________________________________________________________________________________________________________________
Day 4: 
ISP -> Interface Segregation Principle
-> Classes should not be forced to implement what they don't need

Ex:
public interface RestaurantService {   <- Fat Interface
	void takingFoodOrder();
	void serveDrinks();
	void deliverOnline();
	void driveThruService();
}

hands on
1. Create an InvoiceService which depends on the Email Notification service only. 
2. Create a ReportGenerator to generate reports in 3 formats - Pdf, Html, Excel
3. Connect the generator to the EmailNotificationService

----------------------------------------------------------
Ticketing System - SRP, OCP, LSP and ISP Compliant

hands on
1. add Purchase service
2. add ticket type strategy
3. add a simple payment service
4. Add controller

hands on for the case study
1. add a dedicated OverdueReminderService
2. In the pushnotificationservice, implement the Reservationnotifiactionservice and update the methods
3. Add a fine payment service
________________________________________________________

Day 5:
DIP
-> Dependency Inversion Principle
-> states that:
	- high level modules should not be dependent on low level modules
	- both should depend on abstractions (interfaces)
	- abstractions should not depend on the details, details should depend on abstractions

Ex violating DIP

// low-level
@Component
public class EmailNotificationService {
	public void sendNotification(String to, String message) {
		sysout(...);
	}
} 	

// high level
@Service
public class OrderService {
	private final EmailNotificationService emailService;

	public OrderService() {
		this.emailService = new EmailNotificationService();
	}
}
--------------------------------------------------
DIP compliant

public interface NotificationService {
	void send(String to, String message);
}

@Service
@Primary
public class EmailNotificationService implements NotificationService {
	
	@Override
	public void send(...) {
		//...
	}
}

@Service
public class OrderService {
	
	private final NotificationService service;

	public OrderService(NotificationService service){
		this.service = service;
	}
}

------------------------------------------------------------------

hands on:
1. Make the discount application dynamic based on customer type
2. Make the shipping strategy dynamic based on customer type

----------------------------------------
Create a Vehicle Management System Project which incorporates SRP, OCP, LSP, ISP and DIP
1. Entities: Customer, Vehicle, Mechanic, Maintenance
2. Create the necessary repositories and services.
3. Add NotificationService
4. Add a new Mechanic Type. Example: Electrical mechanic
5. Add a Payment service
6. Add a Invoice service which generates an invoice in PDF format
7. Add Service history to the vehicles
Note: Have at least 2 kinds of vehicles( ex. car and truck)







